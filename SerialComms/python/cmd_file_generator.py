"""
MASA firmware-side command handling C code generation script

Michigan Aeronautical Science Association
Author: Nathaniel Kalantar (nkalan@umich.edu)
Created: December 18, 2020
Updated: December 22, 2020
"""

import file_generator_byte_info as byte_info
import csv
import sys
import time


"""
Main program
Reads in the .csv template and generates files from it
"""
def main():
    # Autogeneration label and timestamp
    begin_autogen_tag = "### BEGIN AUTOGENERATED SECTION - MODIFICATIONS TO THIS CODE WILL BE OVERWRITTEN\n"
    end_autogen_tag = "### END AUTOGENERATED SECTION - USER CODE GOES BELOW THIS LINE\n"
    autogen_label = "### Autogenerated by telem_defines_globals_generate.py on " + time.ctime()

    # Initializing strings to write to files
    s2_command_str = begin_autogen_tag + "\n### s2_command.py\n" + autogen_label + "\n\n" 

    # Initialize a dict, indexed by packet_type, with a list of tuples for (argname, argtype, xmit_scale)
    # TODO: find the version of the template with the xmit scale column
    cmd_args = dict()

    # Open the telem template file
    #filename = sys.argv[1]
    filename = "telem_cmd_template.csv"
    
    with open(filename, newline='') as template_file:
        print("Reading " + filename + "...\n")
        csvread = csv.reader(template_file)  # csv.reader objects work with iterators and are not indexable

        # Create a dictionary mapping column names to column indices from the first row
        col = dict()
        for colnum, colname in enumerate(csvread.__next__()):
            col[colname] = colnum

        # Starts reading from second row. line is a list of strings
        for line in csvread:

            # Parse the row and grab the variables
            packet_type             = int(line[col["packet_type"]])
            function_name           = line[col["function_name"]]
            num_args                = int(line[col["num_args"]])
            
            # TODO: how should it handle arbitrary numbers of arguments?
            arg0                    = line[col["arg0"]]
            arg_type0               = line[col["arg_type0"]]
            xmit_scale0             = line[col["xmit_scale0"]]
            arg1                    = line[col["arg1"]]
            arg_type1               = line[col["arg_type1"]]
            xmit_scale1             = line[col["xmit_scale1"]]
            arg2                    = line[col["arg2"]]
            arg_type2               = line[col["arg_type2"]]
            xmit_scale2             = line[col["xmit_scale2"]]
            
            supported_target_addr   = line[col["supported_target_addr"]]  # Note: this will be defined in a separate file in the future
            description             = line[col["description"]]  # Only for the gui, not used in firmware (I think)

            # Insert the function argument info into the proper list
            cmd_args[packet_type] = list()

            # TODO: add xmit_scale
            # TODO: why did I make this dictionary? need to figure it out
            if num_args > 0:
                cmd_args[packet_type].append( (arg0, arg_type0, xmit_scale0) )
            if num_args > 1:
                cmd_args[packet_type].append( (arg1, arg_type1, xmit_scale1) )
            if num_args > 2:
                cmd_args[packet_type].append( (arg2, arg_type2, xmit_scale2) )
            # TODO: how to include more arguments? Might have to change the template so that all the arguments are at the end and just keep going 

        # for line
    # with open

    # TODO: generate s2_command header comment documentation
    s2_command_str += "def s2_command(target_id, command_id, argc, argv):\n"
    
    # Create an if block for each command
    first_if_block = True
    for (packet_type, arg_list) in cmd_args.items():
        if (first_if_block):
            s2_command_str += "\tif "
            first_if_block = False
        else:
            s2_command_str += "\telif "

        s2_command_str += "(command_id == " + str(packet_type) + "):\n"
        
        # Iterate through the command's arguments and generate their unpacking C code
        for (argname, argtype, xmit_scale) in cmd_args[packet_type]:
            pass
        
        s2_command_str += "\t\tpass\n"

    with open("../src/s2_command.py", "w+") as s2_command:
        s2_command.write(s2_command_str)

if __name__ == '__main__':
    main()