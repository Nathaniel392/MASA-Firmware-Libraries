"""
MASA callibration format and global variables generator script

Michigan Aeronautical Science Association
Authors: Sidharth Anantha (ananthas@umich.edu)
Modified from telem_file_generator.py
Created: July 25, 2021
"""

import time
import sys
import json
import pandas as pd 
import numpy as np 
import file_generator_byte_info as byte_info


"""
Main program
Reads in the telem data .csv template and generates packet decoding .py

REQUIREMENTS:
    1. First command line arg is the input csv file which is required
    2. Second command line arg is optional and is the output py file
        If no second arg is provided, the file will default to ./telemParse.py
    3. Third command line arg is optional and is the output header file
        If no third arg is provided, the file will default to ../inc/globals.h
    3. Fourth command line arg is optional and is the output c file
        If no fourth arg is provided, the file will default to ../inc/globals.c
"""


def main():

    # error_ocurred variable will be used to avoid the program print out that it was
    # successful without having to terminate the program when the first error ocurrs
    error_ocurred = False
    

    # Open the telem template file
    filename = sys.argv[1]
    print("Reading " + filename + "...")

    # Script should read in from a csv and store the data
    # File to read in: "calibration_data_flightec.csv"
    calibration_parameters = pd.read_csv(filename, encoding= 'unicode_escape')
    # Eeach of the cols is now stored in a pandas data structure and can be accessed
    
    # Note: You can also hardcode the file with this:
    # calibration_parameters = pd.read_csv("calibration_data_flightec.csv", encoding= 'unicode_escape')

    
    # Autogeneration label and timestamp - comments not included in some because they're put into C and python files
    begin_autogen_tag = "BEGIN AUTOGENERATED SECTION - MODIFICATIONS TO THIS CODE WILL BE OVERWRITTEN\n"
    autogen_label = "Autogenerated by firmware-libraries/SerialComms/python/calibration_file_generator.py on " + time.ctime()
    end_autogen_tag_c = "/// END AUTOGENERATED SECTION - USER CODE GOES BELOW THIS LINE\n"

    

    # For pack_callibration_defines.h
    pack_calibration_defines_h_string = "/// " + begin_autogen_tag + "\n/// pack_calibration_defines.h\n" + \
                                "/// " + autogen_label + "\n\n" + \
                                "#include \"calibrations.h\"\n" + \
                                "#include <stdint.h>\n\n"

    # For pack_callibration_defines.c
    pack_calibration_defines_c_string = "/// " + begin_autogen_tag + "\n/// pack_calibration_defines.c\n" + \
                                "/// " + autogen_label + "\n\n" + \
                                "#include \"pack_calibration_defines.h\"\n\nvoid pack_calibration_data(uint8_t* dst){\n"

    # Begin iterative process to step through the rows of the csv:
    
    packet_byte_length = 0  # Total bytes in packet (running total)

    for i in range(len(calibration_parameters.index)):
        
        # Only read the marked rows
        should_generate = calibration_parameters['should_generate'][i]

        # Error checking section, make sure it is written properly
        # Only write the value to pack_calibration_defines.h if should_generate is 'y'
        try:
            assert(should_generate == 'y' or should_generate == 'n')
        except:
            error_ocurred = True
            print("[row " + i + "] " + "Error: should_generate can only be 'y' or 'n'")
            
        # Can I delete this???????????
        if (should_generate != 'y'):
            continue

        if(should_generate == 'y'):

            # Error Checking: Check the type cast to be valid
            # Define type_cast var for this row:
            type_cast = calibration_parameters['type_cast'][i]
            try:
                assert type_cast in byte_info.type_byte_lengths.keys()
            except:
                error_ocurred = True
                print("[row " + i + "] " + "Invalid type cast. Valid Types are:\n" + str(type_byte_lengths.keys()))


            # Increment the calibration byte count
            byte_length = byte_info.type_byte_lengths[type_cast]
            packet_byte_length += byte_length

             # Split the variable into byte-sized CALIBRATION_ITEMs and add them to the #defines list in pack_calibration_defines.h
             # Needs to be in the format of:
             # One line for each byte in the total number of bytes for the variable (byte_length number of bytes)
             # #define	CALIBRATION_ITEM_0	((uint32_t) (valve_states*1)) >> 0 
             #          define the item       cast type  firmware variable    ????
             #          w/ number as the                 name * the scalar
             #          unique identifier                factor to convert
             #                                           float to int while
             #                                           maintaining precision


            firmware_variable = calibration_parameters['firmware_variable'][i]
            xmit_scale = calibration_parameters['xmit_scale'][i]



            for b in range(0, byte_length):
                pack_calibration_defines_h_string += "#define\tCALIBRATION_ITEM_" + str(packet_byte_length - byte_length + b) + \
                "\t((" + type_cast + ") (" + str(firmware_variable) + "*" + str(xmit_scale) + ")) >> " + str(8*b) + " \n"


    
    # Now we exit the forloop, as we have completed writing variables to the string
    



    # We have defined all the items, in our h file, now we need to list the number of total items and give docs
    # Add the number of CALIBRATION_ITEMs to pack_calibration_defines, and declare pack_calibration_data() and generate its documentation
    pack_calibration_defines_h_string += "#define\tCLB_NUM_CALIBRATION_ITEMS\t" + str(packet_byte_length) + "\n"
    pack_calibration_defines_h_string += "\n/**\n * Takes in a uint8_t array of size CLB_NUM_CALIBRATION_ITEMS and packs the " \
        + "\n * global variables into it as defined in pack_calibration_defines.h\n *\n * @param dst\t<uint8_t*>\tArray to " \
        + "write the global variables to after packing their bytes for calibrations.\n**/\nextern void pack_calibration_data(uint8_t* dst);\n"




    # Now that we have defined everything in the .h file, we can now populate the .c file

    # Fill up pack_calibration_defines.c with unpacking code

    # Follows the format:
    # *(dst + 0) = CALIBRATION_ITEM_0;
    # cast to pointer
    # 0 or the number is the unique identifier
    
    # We define this for each byte in the packet essentially, so we do it packet_bye_length times

    # Need to create an instance in the .c file for each variable defined in the .h file
    
    for m in range(0, packet_byte_length):
        pack_calibration_defines_c_string += "\t*(dst + " + str(m) + ") = CALIBRATION_ITEM_" + str(m) + ";\n"
    pack_calibration_defines_c_string += "}"


    # Now we will write this string to the file.

    """ Writing to files """

    # ?????? Does anything else need to be written to files?

    
    #!!!!! Temporary, this is only code used for testing. delete after!
    with open("../Inc/pack_calibration_defines.h", "w+") as pack_calibration_defines_h:
        pack_calibration_defines_h.write(pack_calibration_defines_h_string)
    
    with open("../Src/pack_calibration_defines.c", "w+") as pack_calibration_defines_c:
        pack_calibration_defines_c.write(pack_calibration_defines_c_string)

    # This is the correct code that needs to be implemented:
    '''
    with open("../../../Inc/pack_calibration_defines.h", "w+") as pack_calibration_defines_h:
        pack_calibration_defines_h.write(pack_calibration_defines_h_string)
    
    with open("../../../Src/pack_calibration_defines.c", "w+") as pack_calibration_defines_c:
        pack_calibration_defines_c.write(pack_calibration_defines_c_string)
    '''

    # Close all files
    # Don't need to explicitly call, implicitly called with with statement.
    # pack_calibration_defines_h.close()
    # pack_calibration_defines_c.close()


    if not error_ocurred:
        print(filename + " Successfully Parsed!")
        print(" --- Packet statistics --- ")
        print("Packet items: " + str(packet_byte_length/8))
        print("Packet length (bytes): " + str(packet_byte_length))
        print("\nCreated/updated 2 files:\n"+ \
                    "\n../src/pack_calibration_defines.h" + \
                    "\n../src/pack_calibration_defines.c\n" + "\n")
    else:
        print("\nScript failed to complete. One or more errors occurred. See command line or terminal interface for "
            "details.\n")

if __name__ == '__main__':
    main()
