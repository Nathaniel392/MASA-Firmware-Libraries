"""
MASA telemetry format and global variables generator script

Michigan Aeronautical Science Association
Author: Nathaniel Kalantar (nkalan@umich.edu)
Created: November 9, 2020
Updated: November 9, 2020
"""

import time
import sys

# Open the telem template file
filename = sys.argv[1]
template_file = open(filename)
print("Reading " + filename + "...")

# Autogeneration label and timestamp
autogen_label = "/// Autogenerated by telem_defines_globals_generate.py on " + time.ctime() + '\n\n'

# For pack_telem_defines.h
pack_telem_defines_h_string = "/// pack_telem_defines.h\n" + \
							autogen_label + \
							"#include \"globals.h\"\n" + \
							"#include \"config.h\"\n" + \
							"\n"

# For globals.h and globals.c
globals_h_string = "/// globals.h\n" + autogen_label + "\n\n"
globals_c_string = "/// globals.c\n" + autogen_label + "\n\n"
prev_global_var_name = ""
prev_global_var_is_array = False

# For byte_packet_template.txt_sprintf-call.c
format_string = ""
argument_string = ""

# For hotfire_packet.py
python_string = ""
csv_header = "Time (s),"
self_init = ""
log_string = "\t\tself.log_string = str(time.clock())+','"

globals_string = "\t\t## GLOBALS ##\n"
#device_list = []
col = {}  # Dictionary mapping column names to indices
packet_byte_length = 0	# Total bytes in packet (running total)

# Expected number of bytes for a given variable type
type_byte_lengths = {
	"char"		:	1,
	"uint8_t"	:	1,
	"int8_t"	:	1,
	"uint16_t"	:	2,
	"int16_t"	:	2,
	"uint32_t"	:	4,
	"int32_t"	:	4,
	"uint64_t"	:	8,
	"int64_t"	:	8
}

# Upper bound for a given variable type
type_range_positive = {
	"char"		:	255,
	"uint8_t"	:	(2**8)-1,
	"int8_t"	:	((2**8)/2)-1,
	"uint16_t"	:	(2**16)-1,
	"int16_t"	:	((2**16)/2)-1,
	"uint32_t"	:	(2**32)-1,
	"int32_t"	:	((2**32)/2)-1,
	"uint64_t"	:	(2**64)-1,
	"int64_t"	:	((2**64)/2)-1
}

# Lower bound for a given variable type
type_range_negative = {
	"char"		:	0,
	"uint8_t"	:	0,
	"int8_t"	:	-((2**8)/2),
	"uint16_t"	:	0,
	"int16_t"	:	-((2**16)/2),
	"uint32_t"	:	0,
	"int32_t"	:	-((2**32)/2),
	"uint64_t"	:	0,
	"int64_t"	:	-((2**64)/2)
}

# Used for python_string and hotfire_packet.py
type_unpack_arg = {
	"char"		:	"\"<c\"",
	"uint8_t"	:	"\"<B\"",
	"int8_t"	:	"\"<b\"",
	"uint16_t"	:	"\"<H\"",
	"int16_t"	:	"\"<h\"",
	"uint32_t"	:	"\"<I\"",
	"int32_t"	:	"\"<i\"",
	"uint64_t"	:	"\"<L\"",
	"int64_t"	:	"\"<l\"",
}

python_variables = []

# Iterate through each line of 
num_telem_items = 0
for line in template_file:
	if(num_telem_items == 0):	# First line of the file
		split_string = line.split('\t')
		c = 0
		for arg in split_string:
			col[arg] = c
			c += 1

	else:	# Rest of the file with real data

		# Parse the row and store each datum into a variable
		#split_string = line.split('\t')
		split_string = line.split('\t')

		name = split_string[col['name']]
		firmware_variable  = split_string[col['firmware_variable']]
		min_val	 = split_string[col['min_val']]
		max_val	 = split_string[col['max_val']]
		unit  = split_string[col['unit']]
		firmware_type  = split_string[col['firmware_type']]
		printf_format  = split_string[col['printf_format']]
		type_cast  = split_string[col['type_cast']]
		xmit_scale	= split_string[col['xmit_scale']]

		# Commented rows were used in the EC firmware, but not the new firmware.
		device	 = split_string[col['device']]
		python_variable_override  = split_string[col['python_variable_override']]
		python_type  = split_string[col['python_type']]
		python_globals	 = split_string[col['python_globals']]
		python_init  = split_string[col['python_init']]
		
		#firmware_globals_type = split_string[col['firmware_globals_type']]  # Technically firmware_globals_name but w/e
		#should_generate = split_string[col['should_generate']]

		# Only write the value to pack_telem_defines.h if should_generate is 'yes'
		#if (should_generate == 'n'):
		#	continue

		""" Add line(s) to pack_telem_defines.h """

		# Check the type cast
		try:
			assert type_cast in type_byte_lengths.keys()
		except:
			print("Invalid type cast. Valid Types are:\n" + str(type_byte_lengths.keys()))

		## Check xmit limits: make sure the float scaler doesn't make it go out of range
		try:
			if(min_val):
				assert (float(min_val)*float(xmit_scale) >= type_range_negative[type_cast])
		except:
			print("Invalid type cast for given range on item " + name)
			print("Min val: " + str(float(min_val)*float(xmit_scale)))
			print("Type limit: " + str(type_range_negative[type_cast]))
		try:
			if(max_val):
				assert (float(max_val)*float(xmit_scale) <= type_range_positive[type_cast])
		except:
			print("Invalid type cast for given range on item " + name)
			print("Max val: " + str(float(max_val)*float(xmit_scale)))
			print("Type limit: " + str(type_range_positive[type_cast]))
		## End check xmit limits

		byte_length = type_byte_lengths[type_cast]
		packet_byte_length += byte_length

		# Split the variable into byte-sized TELEM_ITEMs
		for m in range(0, byte_length):
			pack_telem_defines_h_string += "#define\tTELEM_ITEM_" + str(packet_byte_length - byte_length + m) + \
			"\t((" + type_cast + ") (" + str(firmware_variable) + "*" + str(xmit_scale) + ")) >> " + str(8*m) + " \n"


		""" Update globals.h / globals.c strings """
		
		# This code mostly checks if the variable is in an array, if it's not then define it,
		# if it is then keep checking until you reach the end of values that would be in that array

		# Check if it's supposed to be an array
		curr_global_var_is_array = False
		if ('[' in firmware_variable):
			# Make sure the closing bracket is there (idiot check)
			try:
				assert(']' in firmware_variable)
			except:
				print("Invalid firmware variable type: '[' found but ']' not found")
				print("Array variable names must include opening and closing brackets")
			curr_global_var_is_array = True
		
		# If you reach the end of a contiguous block of variable names (array)
		#if (firmware_globals_type != prev_global_var_name and prev_global_var_is_array):
		#	pass  # TODO finish this


		

		prev_global_var_is_array = curr_global_var_is_array



			
		"""
		Pressure transducer calibration generator script:

		3 column cvsv file
		1: channel id (what channel it's connected to on the board)
		2: slope
		3: offest

		generate a .h file
		in the press board firmware, use the calibrations in that header file
		"""

		# Update the byte_packet_template.txt_sprintf-call.c strings
		"""
		format_string = format_string + printf_format.rstrip('\n') +','
		argument_string = argument_string + ("," + firmware_variable)
		"""

		# Update the hotfire_packet.py strings
		
		# Parse Globals
		if(python_globals):
			globals_string = globals_string + "\t\tglobal " + python_globals + '\n'
			self_init += "\t\tself." + python_globals + " = " + python_init + "\n"

		python_variable = firmware_variable
		if(python_variable_override):
			python_variable = python_variable_override

		python_variables.append(python_variable)

		python_string += "\t\tbyte_rep = "
		python_string += "packet[" + str(packet_byte_length - byte_length) + ":" + str(packet_byte_length) + "]"
		python_string += "\n"
		
		python_string +=	"\t\tself." + python_variable+" = " + python_type + \
							"((float(struct.unpack(" + type_unpack_arg[type_cast] + \
							", byte_rep)[0]))/" + xmit_scale + ")\n"

		python_string +=	"\t\tself.dict[self.items[" + str(num_telem_items - 1) + "]] = self." + python_variable + '\n'

		csv_header += python_variable + ' (' + unit + '),'
		log_string += "+str(self." + python_variable + ")+','"
		
		
		#device_list.append(split_string[5])  # unused
	#end else

	num_telem_items += 1
# end for

for m in range(packet_byte_length, 254):  # TODO: why 254?
	pack_telem_defines_h_string += "#define\tTELEM_ITEM_" + str(m) + "\t0\n"

pack_telem_defines_h_string += "#define\tPACKET_SIZE\t" + str(packet_byte_length) + "\n"


# This was commented when I got it, so it's not even used in the EC code

# parse_csv_header = "\tif(write_csv_header):\n"
# parse_csv_header +=  "\t\tdevice_list = [\'"
# for m in range(0, n-1):
#	parse_csv_header += device_list[m]
#	parse_csv_header += "\', \'"
# parse_csv_header += "\']\n"
# parse_csv_header +=  "\t\tfor device in range(0, len(device_list)):\n"
# parse_csv_header +=  "\t\t\tif device_list[device] in alias.keys():\n"
# parse_csv_header +=  "\t\t\t\tdevice_list[device] = alias[device_list[device]]\n"
# parse_csv_header +=  "\t\tcsv_header = \"Time (s),\"\n"
# parse_csv_header +=  "\t\t\tcsv_header.append(device, \",\")\n"
# parse_csv_header +=  "\t\twrite_csv_header = False\n"


# More updating hotfire_packet.py strings

csv_header += "\\n\"\n"

self_init += "\t\tself.log_string = \"\"\n"
self_init += "\t\tself.num_items = " + str(num_telem_items) + "\n"
self_init += "\t\t\n"
self_init += "\t\tself.dict = {}\n"
self_init += "\t\t\n"

self_init += "\t\tself.items = [''] * self.num_items\n"

for index, var in enumerate(python_variables):
	self_init += "\t\tself.items[" + str(index) + "] = \'" + var + "\' \n"


#parsed_printf_file = open((filename + "_sprintf-call_.c"), "w+")
parsed_python_file = open(("hotfire_packet.py"), "w+")

#pack_telem_defines_h = open("../firmware/ECS3D/Src/pack_telem_defines.h", "w+")  # Generates file in EC project
pack_telem_defines_h = open("pack_telem_defines.h", "w+")  # Generates file in current folder

#parsed_printf_file.write("snprintf(line, sizeof(line), \"" + format_string + "\\r\\n\"" + argument_string + ");")

parsed_python_file.write(	"import time\nimport struct\n\nclass ECParse:\n\n" + \
							"\tdef __init__(self):\n\t\tself.csv_header = \"" + \
							csv_header + self_init + "\n"
							"\tdef parse_packet(self, packet):\n" + \
							python_string + \
							log_string)

pack_telem_defines_h.write(pack_telem_defines_h_string)

print(filename + " Successfully Parsed!")
print(" --- Packet statistics --- ")
print("Packet items: " + str(num_telem_items))
print("Packet length (bytes): " + str(packet_byte_length))